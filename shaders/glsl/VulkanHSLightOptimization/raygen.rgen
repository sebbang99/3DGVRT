/*
 * Sogang Univ, Graphics Lab, 2024
 * 
 * Vulkan Hybrid Shadow map Optimization for Light calculation
 * 
 */

#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_nonuniform_qualifier : require

#include "../base/define.glsl"
#include "../base/geometrytypes.glsl"
#include "../base/light.glsl"
#include "../base/pbr.glsl"

layout(constant_id = 0) const uint numOfLights = 1;	
layout(constant_id = 1) const uint numOfPointLights = 1;

struct RayPayload {
	vec3 color;
	float distance;
	vec3 normal;
	uint objectID;
};

layout(location = 0) rayPayloadEXT RayPayload rayPayload;
layout(location = 1) rayPayloadEXT uint payloadSeed;
layout(location = 2) rayPayloadEXT bool shadowed;

layout(binding = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, rgba8) uniform image2D image;
layout(binding = 2) buffer GeometryNodes { GeometryNode nodes[]; } geometryNodes;
layout(binding = 3) uniform uniformBuffer
{
	mat4 viewInverse;
	mat4 projInverse;
	mat4 lightSpace[numOfLights - numOfPointLights];
	Light lights[numOfLights];
} ubo;
layout(binding = 4) uniform sampler2D posSampler;
layout(binding = 5) uniform sampler2D normSampler;
layout(binding = 6) uniform sampler2D albedoSampler;
layout(binding = 7) uniform sampler2D metallicRoughSampler;
layout(binding = 8) uniform sampler2D emisSampler;
layout(binding = 9) uniform samplerCube samplerEnvMap;
layout(binding = 10) uniform sampler2D shadowMap[numOfLights - numOfPointLights];
layout(set = 0, binding = 11) uniform samplerCube pointShadowMap[numOfPointLights];
layout(binding = 12) uniform sampler2D textures[];

const mat4 biasMat = mat4( 
	0.5, 0.0, 0.0, 0.0,
	0.0, 0.5, 0.0, 0.0,
	0.0, 0.0, 1.0, 0.0,
	0.5, 0.5, 0.0, 1.0 );

#define amb 0.1

float textureProj(vec4 shadowCoord, vec2 off, uint shadowmapIdx)
{
    float shadow = 1.0;

    if (shadowCoord.z > -1.0f && shadowCoord.z < 1.0f) 
    {
        float dist = texture(shadowMap[shadowmapIdx], shadowCoord.st + off).r;
		if (shadowCoord.w > 0.0f && dist < shadowCoord.z)
        {
            shadow = amb;
        }
    }
    return shadow;
}

float filterPCF(vec4 sc, uint shadowmapIdx)
{
    ivec2 texDim = textureSize(shadowMap[shadowmapIdx], 0);
    float scale = 1.5f;
    float dx = scale * 1.0f / float(texDim.x);
    float dy = scale * 1.0f / float(texDim.y);

    float shadowFactor = 0.0f;
    int count = 0;
    int range = 2;  // PCF 필터링 범위를 증가시켜 부드러운 그림자 처리

    for (int x = -range; x <= range; x++)
    {
        for (int y = -range; y <= range; y++)
        {
            shadowFactor += textureProj(sc, vec2(dx * x, dy * y), shadowmapIdx);
            count++;
        }
    }
    return shadowFactor / count;
}

float CalculateShadow(vec3 shadowVector, uint shadowmapIdx)
{
	float curDepth = length(shadowVector);
	shadowVector = normalize(shadowVector);

	float sampledDepth = texture(pointShadowMap[nonuniformEXT(shadowmapIdx)], shadowVector).r;
	sampledDepth *= farPlane;

	float ret = 1.0f;
	if (sampledDepth < curDepth - 0.1f)
	{
		ret = amb;
	}

	return ret;
}

float LinearizeDepth(float depth)
{
  float n = 1.0f;
  float f = 500.0f;
  float z = depth;
  return (2.0 * n) / (f + n - z * (f - n));	
}

void main() 
{
	const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5f);	// pixel position
	const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeEXT.xy);	
	vec2 d = inUV * 2.0f - 1.0f;	// pixel position in NDC
	
	vec4 originPos = texture(posSampler, inUV).xyzw;
	vec3 pos = originPos.xyz;
	uint objectID = uint(round(originPos.w * 65535.0f));

	if (objectID-- == 0)
    {
        vec4 target = ubo.projInverse * vec4(d.x, d.y, 1.0f, 1.0f) ;    // (pixel position in EC) / Wc
        vec3 direction = normalize(ubo.viewInverse * vec4(normalize(target.xyz), 0.0f)).xyz;
        vec3 envColor = textureLod(samplerEnvMap, direction, 0.0f).rgb;
        imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(envColor, 1.0f));
        return;
    }

	vec3 albedo = pow(texture(albedoSampler, inUV).rgb, vec3(2.2f));
	vec3 aoRoughnessMetallic = texture(metallicRoughSampler, inUV).rgb;
	vec3 emissive = texture(emisSampler, inUV).rgb;
	if (emissive == vec3(1.0f)) emissive = vec3(0.0f);
	vec3 N = normalize(texture(normSampler, inUV).xyz);

	vec3 V = normalize((ubo.viewInverse * vec4(0.0f, 0.0f, 0.0f, 1.0f)).xyz - pos);

	GeometryNode geometryNode = geometryNodes.nodes[nonuniformEXT(objectID)];
    if(((pushConstants.rayOption.reflection) && (geometryNode.reflectance > 0.0f)) || ((pushConstants.rayOption.refraction) && (geometryNode.refractance > 0.0f))){
		albedo.rgb = vec3(0.0f);
	}
	else {
		geometryNode.refractance = 0.0f;
		geometryNode.reflectance = 0.0f;
	}

	float ior = geometryNode.ior;
	//vec3 F0 = vec3(pow((ior - 1) / (ior + 1), 2));
	vec3 F0 = vec3(((ior - 1) / (ior + 1))*((ior - 1) / (ior + 1)));
	F0 = mix(F0, albedo, aoRoughnessMetallic.b);

	vec3 finalColor = vec3(0.05f) * albedo;	// ambient
	finalColor += emissive;	// emissive

	vec4 ShadowCoord;
	float shadow;
	// Local Shading Part
	{
		for(int i = 0; i < numOfLights; i++) {
			shadowed = false;
			if (pushConstants.rayOption.shadowRay) {
				if (ubo.lights[i].type != POINT_LIGHT) {
					ShadowCoord = ( biasMat * ubo.lightSpace[i] ) * vec4(pos, 1.0f);
					//shadow = textureProj(ShadowCoord / ShadowCoord.w, vec2(0.0));	// No PCF version.
					shadow = filterPCF(ShadowCoord / ShadowCoord.w, i);	// PCF version.
				}
				else {
					shadow = CalculateShadow(pos - ubo.lights[i].position.xyz, i - (numOfLights - numOfPointLights));
				}
				shadowed = (shadow != 1.0f);
			}

			if (!shadowed) {
				vec3 L = ubo.lights[i].position.xyz - pos;
				radiance = ApplyAttenuation(ubo.lights[i].color, length(L), ubo.lights[i].radius);
				L = normalize(L);
  
				vec3 F = FresnelSchlick(max(dot(normalize(V + L), V), 0.0f), F0);
				vec3 specular = (DistributionGGX(N, normalize(V + L), aoRoughnessMetallic.g)
									* GeometrySmith(N, V, L, aoRoughnessMetallic.g) * F)
									/ (4.0f * max(dot(N, V), 0.0f) * max(dot(N, L), 0.0f) + 0.0001f);

				vec3 kD = vec3(1.0f) - F;

				kD = kD - kD * aoRoughnessMetallic.b;	        

				finalColor += (kD * albedo / PI + specular) * radiance * max(dot(N, L), 0.0f) * spot;
			}
		}
	}

	// Reflection and Refraction Part
	const int iterations = ITERATIONS - 1;
	float iorPrev = 1.0f;
	float productKt = 1.0f;
	float productKr = 1.0f;
	V = -V;

	for (int iter = 0; iter < iterations; iter++)
	{
		if (geometryNode.refractance > 0.0f)
		{
			if (dot(V, N) > 0.0f)
			{
				N *= -1.0f;
				iorPrev = geometryNode.ior;
				geometryNode.ior = 1.0f;
			}
			V = normalize(refract(V, N, iorPrev / geometryNode.ior));
			pos -= N * 0.01f;
			productKt *= geometryNode.refractance;
		}
		else if (geometryNode.reflectance > 0.0f)
		{
			V = normalize(reflect(V, N));
			pos += N * 0.01f;
			productKr *= geometryNode.reflectance;
		}
		else
			break;
#if ANY_HIT
		traceRayEXT(topLevelAS, gl_RayFlagsNoneEXT, 0xFF, 0, 0, 0, pos, 0.001f, V, 10000.0f, 0);
#else
		traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, pos, 0.001f, V, 10000.0f, 0);
#endif
		finalColor += productKt * productKr * rayPayload.color;
		if (rayPayload.distance < 0.0f)
		{
			break;
		}
		geometryNode = geometryNodes.nodes[nonuniformEXT(rayPayload.objectID)];
		pos = pos + V * rayPayload.distance;
		N = rayPayload.normal;
	}

	finalColor = pow(finalColor, vec3(1.0f / 2.2f));

	imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(finalColor, 1.0f));	// write a single texel into an image.
}