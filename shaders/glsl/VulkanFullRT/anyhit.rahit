/*
 * Sogang Univ, Graphics Lab, 2024
 * 
 * Abura Soba, 2025
 * 
 * Full Ray Tracing
 *
 * Any hit shader
 */

#version 460

#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

//#include "../base/define.glsl"
//#include "../base/geometrytypes.glsl"
//#include "../base/bufferreferences.glsl"
#include "../base/3dgs.glsl"

//hitAttributeEXT vec2 attribs;
//layout(binding = 4, set = 0) uniform sampler2D textures[];
//layout(binding = 6, set = 0) buffer GeometryNodes { GeometryNode nodes[]; } geometryNodes;

//#include "../base/geometryfunctions.glsl"

layout(location = 0) rayPayloadEXT RayPayload rayPayload;

void compareAndSwapHitPayloadValue(inout Rayhit hit, int idx){
	const float dist = rayPayload.hit[idx].dist;
	if(hit.dist < dist){
		rayPayload.hit[idx].dist = hit.dist;
		const uint id = rayPayload.hit[idx].particleId;
		rayPayload.hit[idx].particleId = hit.particleId;
		hit.dist = dist;
		hit.particleId = id;
	}
}

void main(){
	Rayhit hit = RayHit(gl_PrimitiveID, gl_HitTEXT);

	if(hit.dist < rayPayload.hit[MAX_HIT_PER_TRACE - 1].dist){
#pragma unroll
		for(int i = 0; i < MAX_HIT_PER_TRACE; i++){
			compareAndSwapHitPayloadValue(hit, i);
		}
		/* for loop unroll test */
		//	compareAndSwapHitPayloadValue(hit, 0);
		//	compareAndSwapHitPayloadValue(hit, 1);
		//	compareAndSwapHitPayloadValue(hit, 2);
		//	compareAndSwapHitPayloadValue(hit, 3);
		//	compareAndSwapHitPayloadValue(hit, 4);
		//	compareAndSwapHitPayloadValue(hit, 5);
		//	compareAndSwapHitPayloadValue(hit, 6);
		//	compareAndSwapHitPayloadValue(hit, 7);
		//	compareAndSwapHitPayloadValue(hit, 8);
		//	compareAndSwapHitPayloadValue(hit, 9);
		//	compareAndSwapHitPayloadValue(hit, 10);
		//	compareAndSwapHitPayloadValue(hit, 11);
		//	compareAndSwapHitPayloadValue(hit, 12);
		//	compareAndSwapHitPayloadValue(hit, 13);
		//	compareAndSwapHitPayloadValue(hit, 14);
		//	compareAndSwapHitPayloadValue(hit, 15);

		if(rayPayload.hit[MAX_HIT_PER_TRACE - 1].dist > gl_HitTEXT){
			ignoreIntersectionEXT;
		}
	}
}